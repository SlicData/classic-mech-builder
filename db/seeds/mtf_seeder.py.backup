#!/usr/bin/env python3
"""MTF File Parser for Classic Mech Builder - Working Version"""

import os, re, psycopg2, argparse, logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum

# Enums and Data Classes (simplified)
class TechBase(Enum):
    INNER_SPHERE = "inner_sphere"
    CLAN = "clan"
    MIXED = "mixed"
    PRIMITIVE = "primitive"

class Era(Enum):
    STAR_LEAGUE = "star_league"
    SUCCESSION = "succession"
    CLAN_INVASION = "clan_invasion"
    CIVIL_WAR = "civil_war"
    JIHAD = "jihad"
    DARK_AGE = "dark_age"
    ILCLAN = "ilclan"

class EngineType(Enum):
    FUSION = "fusion"
    XL_FUSION = "xl_fusion"
    LIGHT_FUSION = "light_fusion"
    ICE = "ice"
    COMPACT_FUSION = "compact_fusion"
    OTHER = "other"

class ArmorType(Enum):
    STANDARD = "standard"
    FERRO_FIBROUS = "ferro_fibrous"
    HARDENED = "hardened"
    STEALTH = "stealth"
    ENDO_STEEL = "endo_steel"
    OTHER = "other"

@dataclass
class WeaponData:
    name: str
    location: str
    count: int = 1

@dataclass 
class ArmorData:
    location: str
    armor_front: int
    armor_rear: Optional[int] = None
    internal: int = 0

@dataclass
class EquipmentData:
    name: str
    location: str
    count: int = 1

@dataclass
class CritSlotData:
    location: str
    slot_index: int
    item_type: str
    display_name: str

@dataclass
class MechData:
    chassis: str
    model: str
    tech_base: TechBase
    era: Era
    rules_level: int
    tonnage: int
    battle_value: int
    walk_mp: int
    run_mp: int
    jump_mp: int
    engine_type: EngineType
    engine_rating: int
    heat_sinks: int
    armor_type: ArmorType
    role: Optional[str] = None
    year: Optional[int] = None
    source: Optional[str] = None
    cost_cbill: Optional[int] = None
    weapons: List[WeaponData] = field(default_factory=list)
    armor: List[ArmorData] = field(default_factory=list)
    equipment: List[EquipmentData] = field(default_factory=list)
    crit_slots: List[CritSlotData] = field(default_factory=list)
    quirks: List[str] = field(default_factory=list)

class MTFParser:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def parse_mtf_file(self, file_path: Path) -> Optional[MechData]:
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            chassis_model = self._extract_chassis_model(content)
            if not chassis_model:
                return None
            chassis, model = chassis_model
            
            # Parse movement with validation
            walk_mp = self._parse_walk_mp(content)
            run_mp = self._parse_run_mp(content)
            jump_mp = self._parse_jump_mp(content)
            
            # Validate movement - all functional mechs should have walk MP > 0
            if walk_mp == 0:
                self.logger.error(f"Movement parsing failed for {chassis} {model}: walk_mp = 0")
                self.logger.debug(f"Dumping movement-related lines from {file_path.name}:")
                for line_num, line in enumerate(content.split('\n'), 1):
                    if any(word in line.lower() for word in ['walk', 'jump', 'movement']):
                        self.logger.debug(f"  Line {line_num}: {line.strip()}")
            
            return MechData(
                chassis=chassis, model=model,
                tech_base=self._parse_tech_base(content),
                era=self._parse_era(content),
                rules_level=self._parse_rules_level(content),
                tonnage=self._parse_tonnage(content),
                battle_value=self._calculate_battle_value(content),
                walk_mp=walk_mp,
                run_mp=run_mp,
                jump_mp=jump_mp,
                engine_type=self._parse_engine_type(content),
                engine_rating=self._parse_engine_rating(content),
                heat_sinks=self._parse_heat_sinks(content),
                armor_type=self._parse_armor_type(content),
                role=self._parse_role(content),
                year=self._parse_year(content),
                source=self._parse_source(content),
                cost_cbill=self._parse_cost(content),
                weapons=self._parse_weapons(content),
                armor=self._parse_armor_values(content),
                equipment=self._parse_equipment(content),
                crit_slots=self._parse_crit_slots(content),
                quirks=self._parse_quirks(content)
            )
        except Exception as e:
            self.logger.error(f"Error parsing {file_path}: {e}")
            return None
    
    def _extract_chassis_model(self, content: str) -> Optional[Tuple[str, str]]:
        lines = [line for line in content.strip().split('\n') if not line.startswith('#') and line.strip()]
        if len(lines) >= 2:
            parts = lines[1].strip().split()
            return (parts[0], ' '.join(parts[1:])) if len(parts) >= 2 else (lines[1].strip(), "")
        return None
    
    def _parse_tech_base(self, content: str) -> TechBase:
        match = re.search(r'techbase:\s*(.+)', content, re.IGNORECASE)
        if match:
            value = match.group(1).strip().lower()
            if "inner sphere" in value: return TechBase.INNER_SPHERE
            elif "clan" in value: return TechBase.CLAN
        return TechBase.INNER_SPHERE
    
    def _parse_era(self, content: str) -> Era:
        return Era.SUCCESSION  # Default for simplicity
    
    def _parse_rules_level(self, content: str) -> int:
        match = re.search(r'rules level:\s*(\d+)', content, re.IGNORECASE)
        return int(match.group(1)) if match else 1
    
    def _parse_tonnage(self, content: str) -> int:
        match = re.search(r'mass:\s*(\d+)', content, re.IGNORECASE)
        return int(match.group(1)) if match else 0
    
    def _calculate_battle_value(self, content: str) -> int:
        return self._parse_tonnage(content) * 20  # Simple estimate
    
    def _parse_walk_mp(self, content: str) -> int:
        """Parse walk MP with validation - all mechs should have walk MP > 0"""
        patterns = [
            r'^Walk\s*MP:\s*(\d+)',     # "Walk MP: 8" - primary MTF format
            r'walk\s*mp:\s*(\d+)',      # fallback for variations
        ]
        for pattern in patterns:
            match = re.search(pattern, content, re.MULTILINE | re.IGNORECASE)
            if match:
                walk_mp = int(match.group(1))
                if walk_mp > 0:
                    return walk_mp
                else:
                    self.logger.warning(f"Found walk MP = 0, which is invalid for functional mechs")
                    return walk_mp  # Return it anyway for debugging
        
        # If we get here, parsing failed completely
        self.logger.error(f"Failed to parse walk MP from MTF content")
        return 0
    
    def _parse_run_mp(self, content: str) -> int:
        """Parse run MP - calculate from walk if not explicit"""
        # Try explicit run MP first
        patterns = [
            r'^Run\s*MP:\s*(\d+)',
            r'run\s*mp:\s*(\d+)',
        ]
        for pattern in patterns:
            match = re.search(pattern, content, re.MULTILINE | re.IGNORECASE)
            if match:
                return int(match.group(1))
        
        # Calculate from walk MP (standard BattleTech rule: Run = Walk * 1.5)
        walk_mp = self._parse_walk_mp(content)
        if walk_mp > 0:
            return int(walk_mp * 1.5)
        else:
            self.logger.error(f"Cannot calculate run MP: walk MP is {walk_mp}")
            return 0
    
    def _parse_jump_mp(self, content: str) -> int:
        """Parse jump MP - can legitimately be 0 for non-jump mechs"""
        patterns = [
            r'^Jump\s*MP:\s*(\d+)',     # "Jump MP: 6" - primary MTF format  
            r'jump\s*mp:\s*(\d+)',      # fallback for variations
        ]
        for pattern in patterns:
            match = re.search(pattern, content, re.MULTILINE | re.IGNORECASE)
            if match:
                return int(match.group(1))
        
        self.logger.debug(f"No jump MP found, defaulting to 0")
        return 0
    
    def _parse_engine_type(self, content: str) -> EngineType:
        return EngineType.FUSION  # Default
    
    def _parse_engine_rating(self, content: str) -> int:
        match = re.search(r'engine:\s*(\d+)', content, re.IGNORECASE)
        return int(match.group(1)) if match else 0
    
    def _parse_heat_sinks(self, content: str) -> int:
        match = re.search(r'heat sinks:\s*(\d+)', content, re.IGNORECASE)
        return int(match.group(1)) if match else 0
    
    def _parse_armor_type(self, content: str) -> ArmorType:
        return ArmorType.STANDARD  # Default
    
    def _parse_role(self, content: str) -> Optional[str]:
        return None
    
    def _parse_year(self, content: str) -> Optional[int]:
        match = re.search(r'era:\s*(\d+)', content, re.IGNORECASE)
        return int(match.group(1)) if match else None
    
    def _parse_source(self, content: str) -> Optional[str]:
        match = re.search(r'source:\s*(.+)', content, re.IGNORECASE)
        return match.group(1).strip() if match else None
    
    def _parse_cost(self, content: str) -> Optional[int]:
        return None
    
    def _parse_weapons(self, content: str) -> List[WeaponData]:
        """Enhanced weapon parsing with normalization and classification"""
        weapons = []
        
        # Find weapons count line
        weapons_match = re.search(r'^Weapons:\s*(\d+)', content, re.MULTILINE | re.IGNORECASE)
        if not weapons_match:
            return weapons
        
        weapon_count = int(weapons_match.group(1))
        
        lines = content.split('\n')
        in_weapons = False
        weapons_parsed = 0
        
        for line in lines:
            line = line.strip()
            
            if re.match(r'^Weapons:\s*\d+', line, re.IGNORECASE):
                in_weapons = True
                continue
            
            if in_weapons:
                # Stop at next section or when we've found all weapons
                if not line or re.match(r'^[A-Z][A-Za-z\s]+:', line) or weapons_parsed >= weapon_count:
                    break
                
                # Parse weapon entry patterns:
                # "Autocannon/20, Left Arm"
                # "2 Medium Laser, Right Torso" 
                weapon_data = self._parse_weapon_line(line)
                if weapon_data:
                    weapons.append(weapon_data)
                    weapons_parsed += weapon_data.count
        
        return weapons
    
    def _parse_weapon_line(self, line: str) -> Optional[WeaponData]:
        """Parse individual weapon line"""
        
        # Pattern 1: "Count WeaponName, Location" (e.g., "2 Medium Laser, Right Torso")
        count_pattern = r'^(\d+)\s+(.+?),\s*(.+)
    
    def _parse_armor_values(self, content: str) -> List[ArmorData]:
        armor = []
        patterns = {'LA': r'LA armor:\s*(\d+)', 'RA': r'RA armor:\s*(\d+)', 'CT': r'CT armor:\s*(\d+)', 'HD': r'HD armor:\s*(\d+)'}
        
        for location, pattern in patterns.items():
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                armor.append(ArmorData(location=location, armor_front=int(match.group(1)), internal=self._calc_internal(location)))
        return armor
    
    def _parse_equipment(self, content: str) -> List[EquipmentData]:
        return []  # Simplified for now
    
    def _parse_crit_slots(self, content: str) -> List[CritSlotData]:
        return []  # Simplified for now
    
    def _parse_quirks(self, content: str) -> List[str]:
        return []  # Simplified for now
    
    def _normalize_location(self, location: str) -> str:
        location_map = {'Left Arm': 'LA', 'Right Arm': 'RA', 'Center Torso': 'CT', 'Head': 'HD'}
        return location_map.get(location, location)
    
    def _calc_internal(self, location: str) -> int:
        return 3 if location == 'HD' else 7  # Simplified

class DatabaseSeeder:
    def __init__(self, db_name: str = "cmb_dev"):
        self.db_name = db_name
        self.conn = None
        self.logger = logging.getLogger(__name__)
    
    def connect(self):
        try:
            from db_config import detect_db_config
            config = detect_db_config()
            if config:
                self.conn = psycopg2.connect(**config)
                self.conn.autocommit = True
                self.logger.info(f"Connected as user: {config['user']}")
            else:
                raise Exception("Could not detect database configuration")
        except Exception as e:
            self.logger.error(f"Database connection failed: {e}")
            raise
    
    def insert_mech(self, mech: MechData) -> bool:
        try:
            cursor = self.conn.cursor()
            mech_id = self._insert_mech_main(cursor, mech)
            if not mech_id: 
                return False
            
            # Insert related data
            self._insert_armor_data(cursor, mech_id, mech.armor)
            self._insert_weapon_data(cursor, mech_id, mech.weapons)
            cursor.close()
            return True
        except Exception as e:
            self.logger.error(f"Failed to insert mech {mech.chassis} {mech.model}: {e}")
            return False
    
    def _insert_mech_main(self, cursor, mech: MechData) -> Optional[int]:
        sql = """INSERT INTO mech (chassis, model, tech_base, era, rules_level, tonnage, battle_value, 
                 walk_mp, run_mp, jump_mp, engine_type, engine_rating, heat_sinks, armor_type) 
                 VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                 ON CONFLICT (chassis, model) DO UPDATE SET tonnage = EXCLUDED.tonnage, updated_at = NOW()
                 RETURNING id"""
        
        cursor.execute(sql, (mech.chassis, mech.model, mech.tech_base.value, mech.era.value,
                           mech.rules_level, mech.tonnage, mech.battle_value, mech.walk_mp, mech.run_mp,
                           mech.jump_mp, mech.engine_type.value, mech.engine_rating, mech.heat_sinks,
                           mech.armor_type.value))
        
        result = cursor.fetchone()
        return result[0] if result else None
    
    def _insert_armor_data(self, cursor, mech_id: int, armor_data: List[ArmorData]):
        cursor.execute("DELETE FROM mech_armor WHERE mech_id = %s", (mech_id,))
        for armor in armor_data:
            cursor.execute("INSERT INTO mech_armor (mech_id, loc, armor_front, armor_rear, internal) VALUES (%s, %s, %s, %s, %s)",
                          (mech_id, armor.location, armor.armor_front, armor.armor_rear, armor.internal))
    
    def _insert_weapon_data(self, cursor, mech_id: int, weapons: List[WeaponData]):
        cursor.execute("DELETE FROM mech_weapon WHERE mech_id = %s", (mech_id,))
        for weapon in weapons:
            weapon_id = self._get_or_create_weapon(cursor, weapon.name)
            if weapon_id:
                cursor.execute("INSERT INTO mech_weapon (mech_id, weapon_id, count) VALUES (%s, %s, %s)",
                              (mech_id, weapon_id, weapon.count))
    
    def _get_or_create_weapon(self, cursor, weapon_name: str) -> Optional[int]:
        cursor.execute("SELECT id FROM weapon_catalog WHERE name = %s", (weapon_name,))
        result = cursor.fetchone()
        if result: 
            return result[0]
        
        # Create new weapon with basic classification
        weapon_class = 'energy' if 'laser' in weapon_name.lower() or 'ppc' in weapon_name.lower() else 'ballistic'
        tech_base = 'clan' if weapon_name.upper().startswith('CL') else 'inner_sphere'
        
        cursor.execute("INSERT INTO weapon_catalog (name, class, tech_base) VALUES (%s, %s, %s) RETURNING id",
                      (weapon_name, weapon_class, tech_base))
        result = cursor.fetchone()
        return result[0] if result else None
    
    def close(self):
        if self.conn: 
            self.conn.close()

def find_mtf_files(megamek_path: Path) -> List[Path]:
    mtf_files = []
    search_paths = [megamek_path / "megamek" / "data" / "mechfiles", megamek_path]
    
    for search_path in search_paths:
        if search_path.exists():
            found_files = list(search_path.rglob("*.mtf"))
            mtf_files.extend(found_files)
            if found_files:
                print(f"Found {len(found_files)} MTF files in {search_path}")
    
    return list(set(mtf_files))  # Remove duplicates

def main():
    parser = argparse.ArgumentParser(description='Seed database from MegaMek MTF files')
    parser.add_argument('--megamek-path', type=Path, required=True)
    parser.add_argument('--db-name', default='cmb_dev')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--limit', type=int)
    
    args = parser.parse_args()
    
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)
    
    mtf_files = find_mtf_files(args.megamek_path)
    if not mtf_files:
        logger.error(f"No MTF files found in {args.megamek_path}")
        return
    
    if args.limit:
        mtf_files = mtf_files[:args.limit]
    
    logger.info(f"Found {len(mtf_files)} MTF files to process")
    
    parser_obj = MTFParser()
    db = None
    
    if not args.dry_run:
        db = DatabaseSeeder(args.db_name)
        try:
            db.connect()
        except Exception as e:
            logger.error(f"Failed to connect to database: {e}")
            return
    
    successful = 0
    failed = 0
    
    try:
        for mtf_file in mtf_files:
            logger.info(f"Processing {mtf_file.name}...")
            
            mech_data = parser_obj.parse_mtf_file(mtf_file)
            if mech_data:
                if args.dry_run:
                    logger.info(f"  ✓ {mech_data.chassis} {mech_data.model} ({mech_data.tonnage}t)")
                    logger.info(f"    Weapons: {len(mech_data.weapons)}, Armor: {len(mech_data.armor)}")
                    successful += 1
                else:
                    if db.insert_mech(mech_data):
                        logger.info(f"  ✓ Inserted {mech_data.chassis} {mech_data.model}")
                        successful += 1
                    else:
                        logger.error(f"  ✗ Failed to insert {mech_data.chassis} {mech_data.model}")
                        failed += 1
            else:
                logger.warning(f"  ✗ Failed to parse {mtf_file.name}")
                failed += 1
    
    finally:
        if db:
            db.close()
    
    logger.info(f"Completed: {successful} successful, {failed} failed")

if __name__ == "__main__":
    main()

        match = re.match(count_pattern, line)
        if match:
            count = int(match.group(1))
            weapon_name = self._normalize_weapon_name(match.group(2).strip())
            location = self._normalize_location(match.group(3).strip())
            
            return WeaponData(
                name=weapon_name,
                location=location,
                count=count
            )
        
        # Pattern 2: "WeaponName, Location" (e.g., "Autocannon/20, Left Arm")
        standard_pattern = r'^(.+?),\s*(.+)
    
    def _parse_armor_values(self, content: str) -> List[ArmorData]:
        armor = []
        patterns = {'LA': r'LA armor:\s*(\d+)', 'RA': r'RA armor:\s*(\d+)', 'CT': r'CT armor:\s*(\d+)', 'HD': r'HD armor:\s*(\d+)'}
        
        for location, pattern in patterns.items():
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                armor.append(ArmorData(location=location, armor_front=int(match.group(1)), internal=self._calc_internal(location)))
        return armor
    
    def _parse_equipment(self, content: str) -> List[EquipmentData]:
        return []  # Simplified for now
    
    def _parse_crit_slots(self, content: str) -> List[CritSlotData]:
        return []  # Simplified for now
    
    def _parse_quirks(self, content: str) -> List[str]:
        return []  # Simplified for now
    
    def _normalize_location(self, location: str) -> str:
        location_map = {'Left Arm': 'LA', 'Right Arm': 'RA', 'Center Torso': 'CT', 'Head': 'HD'}
        return location_map.get(location, location)
    
    def _calc_internal(self, location: str) -> int:
        return 3 if location == 'HD' else 7  # Simplified

class DatabaseSeeder:
    def __init__(self, db_name: str = "cmb_dev"):
        self.db_name = db_name
        self.conn = None
        self.logger = logging.getLogger(__name__)
    
    def connect(self):
        try:
            from db_config import detect_db_config
            config = detect_db_config()
            if config:
                self.conn = psycopg2.connect(**config)
                self.conn.autocommit = True
                self.logger.info(f"Connected as user: {config['user']}")
            else:
                raise Exception("Could not detect database configuration")
        except Exception as e:
            self.logger.error(f"Database connection failed: {e}")
            raise
    
    def insert_mech(self, mech: MechData) -> bool:
        try:
            cursor = self.conn.cursor()
            mech_id = self._insert_mech_main(cursor, mech)
            if not mech_id: 
                return False
            
            # Insert related data
            self._insert_armor_data(cursor, mech_id, mech.armor)
            self._insert_weapon_data(cursor, mech_id, mech.weapons)
            cursor.close()
            return True
        except Exception as e:
            self.logger.error(f"Failed to insert mech {mech.chassis} {mech.model}: {e}")
            return False
    
    def _insert_mech_main(self, cursor, mech: MechData) -> Optional[int]:
        sql = """INSERT INTO mech (chassis, model, tech_base, era, rules_level, tonnage, battle_value, 
                 walk_mp, run_mp, jump_mp, engine_type, engine_rating, heat_sinks, armor_type) 
                 VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                 ON CONFLICT (chassis, model) DO UPDATE SET tonnage = EXCLUDED.tonnage, updated_at = NOW()
                 RETURNING id"""
        
        cursor.execute(sql, (mech.chassis, mech.model, mech.tech_base.value, mech.era.value,
                           mech.rules_level, mech.tonnage, mech.battle_value, mech.walk_mp, mech.run_mp,
                           mech.jump_mp, mech.engine_type.value, mech.engine_rating, mech.heat_sinks,
                           mech.armor_type.value))
        
        result = cursor.fetchone()
        return result[0] if result else None
    
    def _insert_armor_data(self, cursor, mech_id: int, armor_data: List[ArmorData]):
        cursor.execute("DELETE FROM mech_armor WHERE mech_id = %s", (mech_id,))
        for armor in armor_data:
            cursor.execute("INSERT INTO mech_armor (mech_id, loc, armor_front, armor_rear, internal) VALUES (%s, %s, %s, %s, %s)",
                          (mech_id, armor.location, armor.armor_front, armor.armor_rear, armor.internal))
    
    def _insert_weapon_data(self, cursor, mech_id: int, weapons: List[WeaponData]):
        cursor.execute("DELETE FROM mech_weapon WHERE mech_id = %s", (mech_id,))
        for weapon in weapons:
            weapon_id = self._get_or_create_weapon(cursor, weapon.name)
            if weapon_id:
                cursor.execute("INSERT INTO mech_weapon (mech_id, weapon_id, count) VALUES (%s, %s, %s)",
                              (mech_id, weapon_id, weapon.count))
    
    def _get_or_create_weapon(self, cursor, weapon_name: str) -> Optional[int]:
        cursor.execute("SELECT id FROM weapon_catalog WHERE name = %s", (weapon_name,))
        result = cursor.fetchone()
        if result: 
            return result[0]
        
        # Create new weapon with basic classification
        weapon_class = 'energy' if 'laser' in weapon_name.lower() or 'ppc' in weapon_name.lower() else 'ballistic'
        tech_base = 'clan' if weapon_name.upper().startswith('CL') else 'inner_sphere'
        
        cursor.execute("INSERT INTO weapon_catalog (name, class, tech_base) VALUES (%s, %s, %s) RETURNING id",
                      (weapon_name, weapon_class, tech_base))
        result = cursor.fetchone()
        return result[0] if result else None
    
    def close(self):
        if self.conn: 
            self.conn.close()

def find_mtf_files(megamek_path: Path) -> List[Path]:
    mtf_files = []
    search_paths = [megamek_path / "megamek" / "data" / "mechfiles", megamek_path]
    
    for search_path in search_paths:
        if search_path.exists():
            found_files = list(search_path.rglob("*.mtf"))
            mtf_files.extend(found_files)
            if found_files:
                print(f"Found {len(found_files)} MTF files in {search_path}")
    
    return list(set(mtf_files))  # Remove duplicates

def main():
    parser = argparse.ArgumentParser(description='Seed database from MegaMek MTF files')
    parser.add_argument('--megamek-path', type=Path, required=True)
    parser.add_argument('--db-name', default='cmb_dev')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--limit', type=int)
    
    args = parser.parse_args()
    
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)
    
    mtf_files = find_mtf_files(args.megamek_path)
    if not mtf_files:
        logger.error(f"No MTF files found in {args.megamek_path}")
        return
    
    if args.limit:
        mtf_files = mtf_files[:args.limit]
    
    logger.info(f"Found {len(mtf_files)} MTF files to process")
    
    parser_obj = MTFParser()
    db = None
    
    if not args.dry_run:
        db = DatabaseSeeder(args.db_name)
        try:
            db.connect()
        except Exception as e:
            logger.error(f"Failed to connect to database: {e}")
            return
    
    successful = 0
    failed = 0
    
    try:
        for mtf_file in mtf_files:
            logger.info(f"Processing {mtf_file.name}...")
            
            mech_data = parser_obj.parse_mtf_file(mtf_file)
            if mech_data:
                if args.dry_run:
                    logger.info(f"  ✓ {mech_data.chassis} {mech_data.model} ({mech_data.tonnage}t)")
                    logger.info(f"    Weapons: {len(mech_data.weapons)}, Armor: {len(mech_data.armor)}")
                    successful += 1
                else:
                    if db.insert_mech(mech_data):
                        logger.info(f"  ✓ Inserted {mech_data.chassis} {mech_data.model}")
                        successful += 1
                    else:
                        logger.error(f"  ✗ Failed to insert {mech_data.chassis} {mech_data.model}")
                        failed += 1
            else:
                logger.warning(f"  ✗ Failed to parse {mtf_file.name}")
                failed += 1
    
    finally:
        if db:
            db.close()
    
    logger.info(f"Completed: {successful} successful, {failed} failed")

if __name__ == "__main__":
    main()

        match = re.match(standard_pattern, line)
        if match:
            weapon_name = self._normalize_weapon_name(match.group(1).strip())
            location = self._normalize_location(match.group(2).strip())
            
            return WeaponData(
                name=weapon_name,
                location=location,
                count=1
            )
        
        return None
    
    def _normalize_weapon_name(self, name: str) -> str:
        """Normalize weapon names using alias mapping"""
        name_lower = name.lower().strip()
        weapon_aliases = {
            # Autocannons
            'ac/2': 'Autocannon/2',
            'ac/5': 'Autocannon/5', 
            'ac/10': 'Autocannon/10',
            'ac/20': 'Autocannon/20',
            'autocannon/2': 'Autocannon/2',
            'autocannon/5': 'Autocannon/5',
            'autocannon/10': 'Autocannon/10',
            'autocannon/20': 'Autocannon/20',
            
            # Lasers
            'small laser': 'Small Laser',
            'medium laser': 'Medium Laser',
            'large laser': 'Large Laser',
            'er small laser': 'ER Small Laser',
            'er medium laser': 'ER Medium Laser', 
            'er large laser': 'ER Large Laser',
            
            # PPCs
            'ppc': 'PPC',
            'er ppc': 'ER PPC',
            
            # Missiles
            'lrm 5': 'LRM 5', 'lrm 10': 'LRM 10', 'lrm 15': 'LRM 15', 'lrm 20': 'LRM 20',
            'lrm-5': 'LRM 5', 'lrm-10': 'LRM 10', 'lrm-15': 'LRM 15', 'lrm-20': 'LRM 20',
            'srm 2': 'SRM 2', 'srm 4': 'SRM 4', 'srm 6': 'SRM 6',
            'srm-2': 'SRM 2', 'srm-4': 'SRM 4', 'srm-6': 'SRM 6',
            
            # Other weapons
            'machine gun': 'Machine Gun',
            'flamer': 'Flamer',
            'gauss rifle': 'Gauss Rifle',
        }
        return weapon_aliases.get(name_lower, name.strip())
    
    def _parse_armor_values(self, content: str) -> List[ArmorData]:
        armor = []
        patterns = {'LA': r'LA armor:\s*(\d+)', 'RA': r'RA armor:\s*(\d+)', 'CT': r'CT armor:\s*(\d+)', 'HD': r'HD armor:\s*(\d+)'}
        
        for location, pattern in patterns.items():
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                armor.append(ArmorData(location=location, armor_front=int(match.group(1)), internal=self._calc_internal(location)))
        return armor
    
    def _parse_equipment(self, content: str) -> List[EquipmentData]:
        return []  # Simplified for now
    
    def _parse_crit_slots(self, content: str) -> List[CritSlotData]:
        return []  # Simplified for now
    
    def _parse_quirks(self, content: str) -> List[str]:
        return []  # Simplified for now
    
    def _normalize_location(self, location: str) -> str:
        location_map = {'Left Arm': 'LA', 'Right Arm': 'RA', 'Center Torso': 'CT', 'Head': 'HD'}
        return location_map.get(location, location)
    
    def _calc_internal(self, location: str) -> int:
        return 3 if location == 'HD' else 7  # Simplified

class DatabaseSeeder:
    def __init__(self, db_name: str = "cmb_dev"):
        self.db_name = db_name
        self.conn = None
        self.logger = logging.getLogger(__name__)
    
    def connect(self):
        try:
            from db_config import detect_db_config
            config = detect_db_config()
            if config:
                self.conn = psycopg2.connect(**config)
                self.conn.autocommit = True
                self.logger.info(f"Connected as user: {config['user']}")
            else:
                raise Exception("Could not detect database configuration")
        except Exception as e:
            self.logger.error(f"Database connection failed: {e}")
            raise
    
    def insert_mech(self, mech: MechData) -> bool:
        try:
            cursor = self.conn.cursor()
            mech_id = self._insert_mech_main(cursor, mech)
            if not mech_id: 
                return False
            
            # Insert related data
            self._insert_armor_data(cursor, mech_id, mech.armor)
            self._insert_weapon_data(cursor, mech_id, mech.weapons)
            cursor.close()
            return True
        except Exception as e:
            self.logger.error(f"Failed to insert mech {mech.chassis} {mech.model}: {e}")
            return False
    
    def _insert_mech_main(self, cursor, mech: MechData) -> Optional[int]:
        sql = """INSERT INTO mech (chassis, model, tech_base, era, rules_level, tonnage, battle_value, 
                 walk_mp, run_mp, jump_mp, engine_type, engine_rating, heat_sinks, armor_type) 
                 VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                 ON CONFLICT (chassis, model) DO UPDATE SET tonnage = EXCLUDED.tonnage, updated_at = NOW()
                 RETURNING id"""
        
        cursor.execute(sql, (mech.chassis, mech.model, mech.tech_base.value, mech.era.value,
                           mech.rules_level, mech.tonnage, mech.battle_value, mech.walk_mp, mech.run_mp,
                           mech.jump_mp, mech.engine_type.value, mech.engine_rating, mech.heat_sinks,
                           mech.armor_type.value))
        
        result = cursor.fetchone()
        return result[0] if result else None
    
    def _insert_armor_data(self, cursor, mech_id: int, armor_data: List[ArmorData]):
        cursor.execute("DELETE FROM mech_armor WHERE mech_id = %s", (mech_id,))
        for armor in armor_data:
            cursor.execute("INSERT INTO mech_armor (mech_id, loc, armor_front, armor_rear, internal) VALUES (%s, %s, %s, %s, %s)",
                          (mech_id, armor.location, armor.armor_front, armor.armor_rear, armor.internal))
    
    def _insert_weapon_data(self, cursor, mech_id: int, weapons: List[WeaponData]):
        cursor.execute("DELETE FROM mech_weapon WHERE mech_id = %s", (mech_id,))
        for weapon in weapons:
            weapon_id = self._get_or_create_weapon(cursor, weapon.name)
            if weapon_id:
                cursor.execute("INSERT INTO mech_weapon (mech_id, weapon_id, count) VALUES (%s, %s, %s)",
                              (mech_id, weapon_id, weapon.count))
    
    def _get_or_create_weapon(self, cursor, weapon_name: str) -> Optional[int]:
        cursor.execute("SELECT id FROM weapon_catalog WHERE name = %s", (weapon_name,))
        result = cursor.fetchone()
        if result: 
            return result[0]
        
        # Create new weapon with basic classification
        weapon_class = 'energy' if 'laser' in weapon_name.lower() or 'ppc' in weapon_name.lower() else 'ballistic'
        tech_base = 'clan' if weapon_name.upper().startswith('CL') else 'inner_sphere'
        
        cursor.execute("INSERT INTO weapon_catalog (name, class, tech_base) VALUES (%s, %s, %s) RETURNING id",
                      (weapon_name, weapon_class, tech_base))
        result = cursor.fetchone()
        return result[0] if result else None
    
    def close(self):
        if self.conn: 
            self.conn.close()

def find_mtf_files(megamek_path: Path) -> List[Path]:
    mtf_files = []
    search_paths = [megamek_path / "megamek" / "data" / "mechfiles", megamek_path]
    
    for search_path in search_paths:
        if search_path.exists():
            found_files = list(search_path.rglob("*.mtf"))
            mtf_files.extend(found_files)
            if found_files:
                print(f"Found {len(found_files)} MTF files in {search_path}")
    
    return list(set(mtf_files))  # Remove duplicates

def main():
    parser = argparse.ArgumentParser(description='Seed database from MegaMek MTF files')
    parser.add_argument('--megamek-path', type=Path, required=True)
    parser.add_argument('--db-name', default='cmb_dev')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--limit', type=int)
    
    args = parser.parse_args()
    
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)
    
    mtf_files = find_mtf_files(args.megamek_path)
    if not mtf_files:
        logger.error(f"No MTF files found in {args.megamek_path}")
        return
    
    if args.limit:
        mtf_files = mtf_files[:args.limit]
    
    logger.info(f"Found {len(mtf_files)} MTF files to process")
    
    parser_obj = MTFParser()
    db = None
    
    if not args.dry_run:
        db = DatabaseSeeder(args.db_name)
        try:
            db.connect()
        except Exception as e:
            logger.error(f"Failed to connect to database: {e}")
            return
    
    successful = 0
    failed = 0
    
    try:
        for mtf_file in mtf_files:
            logger.info(f"Processing {mtf_file.name}...")
            
            mech_data = parser_obj.parse_mtf_file(mtf_file)
            if mech_data:
                if args.dry_run:
                    logger.info(f"  ✓ {mech_data.chassis} {mech_data.model} ({mech_data.tonnage}t)")
                    logger.info(f"    Weapons: {len(mech_data.weapons)}, Armor: {len(mech_data.armor)}")
                    successful += 1
                else:
                    if db.insert_mech(mech_data):
                        logger.info(f"  ✓ Inserted {mech_data.chassis} {mech_data.model}")
                        successful += 1
                    else:
                        logger.error(f"  ✗ Failed to insert {mech_data.chassis} {mech_data.model}")
                        failed += 1
            else:
                logger.warning(f"  ✗ Failed to parse {mtf_file.name}")
                failed += 1
    
    finally:
        if db:
            db.close()
    
    logger.info(f"Completed: {successful} successful, {failed} failed")

if __name__ == "__main__":
    main()
